import { PrismaClient } from "../src/generated/prisma";
import { blake3 } from "@noble/hashes/blake3";

const prisma = new PrismaClient();

// Generate fingerprint from sentence
function generateFingerprint(sentence: string): string {
  const encoder = new TextEncoder();
  const data = encoder.encode(sentence);
  return Buffer.from(blake3(data)).toString("hex");
}

// Sample sentences that could be generated by models
const sampleSentences = [
  "The quantum computer performed calculations at unprecedented speed.",
  "The quantum computer performed calculations with unprecedented speed.", // slight variation
  "The quantum computer executed calculations at unprecedented speed.", // word change
  "Machine learning algorithms continue to evolve and improve.",
  "Machine learning algorithms continue to evolve and adapt.", // variation
  "Artificial intelligence will transform how we work and live.",
  "The database query returned exactly 42 results from the search.",
  "The database query returned precisely 42 results from the search.", // variation
];

async function main() {
  console.log("ðŸŒ± Starting seed...");

  // Create or find providers
  const anthropicProvider = await prisma.provider.upsert({
    where: { name: "anthropic" },
    update: {},
    create: {
      name: "anthropic",
      displayName: "Anthropic",
      apiBaseUrl: "https://api.anthropic.com",
      npmPackage: "@ai-sdk/anthropic",
      envVars: ["ANTHROPIC_API_KEY"],
      docUrl: "https://docs.anthropic.com",
    },
  });

  const openaiProvider = await prisma.provider.upsert({
    where: { name: "openai" },
    update: {},
    create: {
      name: "openai",
      displayName: "OpenAI",
      apiBaseUrl: "https://api.openai.com",
      npmPackage: "@ai-sdk/openai",
      envVars: ["OPENAI_API_KEY"],
      docUrl: "https://platform.openai.com/docs",
    },
  });

  const googleProvider = await prisma.provider.upsert({
    where: { name: "google" },
    update: {},
    create: {
      name: "google",
      displayName: "Google",
      apiBaseUrl: "https://generativelanguage.googleapis.com",
      npmPackage: "@ai-sdk/google",
      envVars: ["GOOGLE_GENERATIVE_AI_API_KEY"],
      docUrl: "https://ai.google.dev/docs",
    },
  });

  console.log("âœ… Providers created");

  // Create or find models
  const claude35Sonnet = await prisma.model.upsert({
    where: {
      providerId_name: {
        providerId: anthropicProvider.id,
        name: "claude-3-5-sonnet-20241022",
      },
    },
    update: {},
    create: {
      name: "claude-3-5-sonnet-20241022",
      displayName: "Claude 3.5 Sonnet",
      version: "20241022",
      providerId: anthropicProvider.id,
      supportsAttachments: true,
      supportsReasoning: false,
      supportsToolCall: true,
      supportsStreaming: true,
      contextLimit: 200000,
      outputLimit: 4096,
      knowledgeCutoff: "2024-04-30",
      releaseDate: new Date("2024-10-22"),
      inputModalities: ["text", "image"],
      outputModalities: ["text"],
      inputCostPer1M: 3.0,
      outputCostPer1M: 15.0,
    },
  });

  const gpt4Turbo = await prisma.model.upsert({
    where: {
      providerId_name: {
        providerId: openaiProvider.id,
        name: "gpt-4-turbo",
      },
    },
    update: {},
    create: {
      name: "gpt-4-turbo",
      displayName: "GPT-4 Turbo",
      providerId: openaiProvider.id,
      supportsAttachments: true,
      supportsToolCall: true,
      supportsStreaming: true,
      contextLimit: 128000,
      outputLimit: 4096,
      knowledgeCutoff: "2024-04-30",
      inputModalities: ["text", "image"],
      outputModalities: ["text"],
      inputCostPer1M: 10.0,
      outputCostPer1M: 30.0,
    },
  });

  const geminiPro = await prisma.model.upsert({
    where: {
      providerId_name: {
        providerId: googleProvider.id,
        name: "gemini-1.5-pro",
      },
    },
    update: {},
    create: {
      name: "gemini-1.5-pro",
      displayName: "Gemini 1.5 Pro",
      version: "1.5",
      providerId: googleProvider.id,
      supportsAttachments: true,
      supportsToolCall: true,
      supportsStreaming: true,
      contextLimit: 1000000,
      outputLimit: 8192,
      inputModalities: ["text", "image", "audio", "video"],
      outputModalities: ["text"],
      inputCostPer1M: 3.5,
      outputCostPer1M: 10.5,
    },
  });

  console.log("âœ… Models created");

  // Check if we already have fingerprints for these models
  const existingFingerprints = await prisma.fingerprint.count({
    where: {
      modelId: {
        in: [claude35Sonnet.id, gpt4Turbo.id, geminiPro.id],
      },
    },
  });

  if (existingFingerprints > 0) {
    console.log(
      `âš ï¸  Found ${existingFingerprints} existing fingerprints, skipping fingerprint creation`,
    );
    console.log("ðŸŽ‰ Seed completed!");
    return;
  }

  // Create evaluations and fingerprints
  const models = [claude35Sonnet, gpt4Turbo, geminiPro];

  for (const model of models) {
    console.log(`ðŸ“Š Creating fingerprints for ${model.displayName}...`);

    // Determine stability pattern for each model
    let sentencePattern: string[];
    let stabilityLevel: "stable" | "warning" | "critical";

    if (model.name.includes("claude")) {
      // Claude is very stable - mostly same sentence
      sentencePattern = Array(25)
        .fill(sampleSentences[0])
        .concat(
          Array(3).fill(sampleSentences[1]),
          Array(2).fill(sampleSentences[2]),
        );
      stabilityLevel = "stable";
    } else if (model.name.includes("gpt")) {
      // GPT-4 has moderate instability
      sentencePattern = [
        ...Array(10).fill(sampleSentences[3]),
        ...Array(8).fill(sampleSentences[4]),
        ...Array(5).fill(sampleSentences[0]),
        ...Array(4).fill(sampleSentences[1]),
        ...Array(3).fill(sampleSentences[5]),
      ];
      stabilityLevel = "warning";
    } else {
      // Gemini is unstable - many variations
      sentencePattern = sampleSentences.flatMap((sentence) =>
        Array(4).fill(sentence),
      );
      stabilityLevel = "critical";
    }

    // Create fingerprints over the last 30 days
    const now = new Date();
    for (let day = 0; day < 30; day++) {
      const date = new Date(now);
      date.setDate(now.getDate() - (30 - day));

      // Create 1-3 evaluations per day
      const evaluationsPerDay = Math.floor(Math.random() * 3) + 1;

      for (let evalIndex = 0; evalIndex < evaluationsPerDay; evalIndex++) {
        const evalDate = new Date(date);
        evalDate.setHours(evalDate.getHours() + evalIndex * 8); // Spread throughout day

        // Select sentence based on pattern
        const sentenceIndex =
          (day * evaluationsPerDay + evalIndex) % sentencePattern.length;
        const selectedSentence = sentencePattern[sentenceIndex];

        const fingerprint = generateFingerprint(selectedSentence);

        // Create evaluation
        const evaluation = await prisma.evaluation.create({
          data: {
            modelId: model.id,
            testType: "quantization_detection",
            status: "COMPLETED",
            startedAt: evalDate,
            completedAt: new Date(evalDate.getTime() + 30000), // 30 seconds later
            duration: 30,
            totalTests: 10,
            successfulTests: 10,
            failedTests: 0,
          },
        });

        // Create fingerprint
        const createdFingerprint = await prisma.fingerprint.create({
          data: {
            checksum: fingerprint,
            finalSentence: selectedSentence,
            modelId: model.id,
            evaluationId: evaluation.id,
            timestamp: evalDate,
          },
        });

        // Create sample prompt responses for this fingerprint
        for (let step = 1; step <= 10; step++) {
          await prisma.promptResponse.create({
            data: {
              fingerprintId: createdFingerprint.id,
              stepNumber: step,
              prompt: `Step ${step}: Continue this sentence...`,
              rawResponse: `Step ${step} response: ${selectedSentence.split(" ").slice(0, step).join(" ")}`,
              extractedAnswer: selectedSentence
                .split(" ")
                .slice(0, step)
                .join(" "),
              responseTime: Math.floor(Math.random() * 2000) + 500,
              timestamp: new Date(evalDate.getTime() + step * 1000),
            },
          });
        }
      }
    }

    console.log(
      `âœ… Created fingerprints for ${model.displayName} (${stabilityLevel})`,
    );
  }

  console.log("ðŸŽ‰ Seed completed!");
}

main()
  .catch((e) => {
    console.error("âŒ Seed failed:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
